/* eslint-disable no-undef */
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate, NetworkFirst, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST || []);

// =============================================================================
// 1. IMAGES & STATIC MEDIA - Long-term cache
// =============================================================================
registerRoute(
  ({ request, url }) => {
    return (
      request.destination === 'image' ||
      /\.(png|jpg|jpeg|svg|gif|webp|ico)$/i.test(url.pathname) ||
      url.pathname.includes('/media/')
    );
  },
  new CacheFirst({
    cacheName: 'images-cache-v1',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 300,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// =============================================================================
// 2. FONTS - Cache first, long-term
// =============================================================================
registerRoute(
  ({ request, url }) => {
    return (
      request.destination === 'font' ||
      /\.(woff|woff2|ttf|otf|eot)$/i.test(url.pathname)
    );
  },
  new CacheFirst({
    cacheName: 'fonts-cache-v1',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        purgeOnQuotaError: true,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// =============================================================================
// 3. PUBLIC API - GET requests (catalog, products) => StaleWhileRevalidate
// =============================================================================
registerRoute(
  ({ url, request }) => {
    if (request.method !== 'GET') return false;
    
    // Match REST API or GraphQL GET requests
    return (
      url.pathname.includes('/rest') || 
      url.pathname.includes('/graphql')
    );
  },
  new StaleWhileRevalidate({
    cacheName: 'public-api-cache-v1',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60, // 1 hour
        purgeOnQuotaError: true,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// =============================================================================
// 4. AUTHENTICATED API REQUESTS - NetworkFirst for freshness
// =============================================================================
registerRoute(
  ({ request, url }) => {
    // Check for authorization header or cookie-based auth
    const hasAuthHeader = request.headers.has('authorization');
    const hasCookie = request.headers.get('cookie')?.includes('customer_token') || 
                      request.headers.get('cookie')?.includes('session');
    
    const isApiRequest = url.pathname.includes('/rest') || 
                        url.pathname.includes('/graphql');
    
    return isApiRequest && (hasAuthHeader || hasCookie);
  },
  new NetworkFirst({
    cacheName: 'auth-api-cache-v1',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({ 
        maxEntries: 100, 
        maxAgeSeconds: 5 * 60, // 5 minutes (short TTL for auth data)
        purgeOnQuotaError: true,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// =============================================================================
// 5. BACKGROUND SYNC - Queue failed POST requests (cart, checkout)
// =============================================================================
const cartBgSync = new BackgroundSyncPlugin('cartQueue', {
  maxRetentionTime: 24 * 60, // Retry for 24 hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
        console.log('Background sync: Request replayed successfully');
      } catch (error) {
        console.error('Background sync: Replay failed, re-queuing', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// Queue cart-related POST requests
registerRoute(
  ({ url, request }) =>
    request.method === 'POST' &&
    (url.pathname.includes('/carts') || 
     url.pathname.includes('/checkout')),
  new NetworkOnly({ 
    plugins: [cartBgSync] 
  }),
  'POST'
);

// =============================================================================
// 6. GRAPHQL MUTATIONS - NetworkOnly (don't cache POST/mutations)
// =============================================================================
registerRoute(
  ({ url, request }) => 
    request.method === 'POST' && 
    url.pathname.includes('/graphql'),
  new NetworkOnly()
);

// =============================================================================
// 7. NAVIGATION REQUESTS - Fallback to offline page on network failure
// =============================================================================
const navigationHandler = async ({ event }) => {
  try {
    // Try to fetch from network
    const response = await fetch(event.request);
    return response;
  } catch (error) {
    // If network fails, try cache
    const cache = await caches.open('pages-cache-v1');
    const cachedResponse = await cache.match(event.request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // Last resort: offline page (must be in your public folder)
    const offlinePage = await caches.match('/offline.html');
    if (offlinePage) {
      return offlinePage;
    }
    
    // If no offline page, return a basic HTML response
    return new Response(
      `<!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>Offline</title>
          <style>
            body {
              font-family: system-ui, -apple-system, sans-serif;
              display: flex;
              align-items: center;
              justify-content: center;
              min-height: 100vh;
              margin: 0;
              background: #f3f4f6;
            }
            .container {
              text-align: center;
              padding: 2rem;
            }
            h1 { color: #111827; margin-bottom: 1rem; }
            p { color: #6b7280; }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>You're Offline</h1>
            <p>Please check your internet connection and try again.</p>
          </div>
        </body>
      </html>`,
      {
        headers: { 'Content-Type': 'text/html' },
      }
    );
  }
};

registerRoute(
  new NavigationRoute(navigationHandler)
);

// =============================================================================
// 8. SKIP WAITING - Allow immediate activation of new SW
// =============================================================================
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Log SW activation
self.addEventListener('activate', (event) => {
  console.log('Service Worker activated');
});

self.addEventListener('install', (event) => {
  console.log('Service Worker installed');
});